# Использование команды git branch для слияния файла

Администратор космических станций имеет определенные обязанности. Иногда приходится ограничивать доступ к информации, особенно при добавлении на карту местоположения новых станций в солнечной системе. Освоив работу с ветками, вы сможете обновлять файлы и делиться информацией, когда будете к этому готовы.

В полной мере потенциал веток раскрывается при работе в команде. Вы можете работать над своей частью проекта из своей ветки, получать изменения из Bitbucket и выполнять слияние всех результатов своей работы, когда она будет готова, с главной веткой. В нашей документации подробно описано, для чего используются ветки.

Ветка представляет собой независимое направление разработки в репозитории. Ее можно рассматривать как новое сочетание рабочего каталога, раздела проиндексированных файлов и истории проекта. Создание новых веток автоматически начинается с главной ветки (main). В качестве наглядного примера на этой схеме показаны главная ветка и ветка с обновлением для исправления багов.

# Ветвление в Git

# Шаг 1. Создание ветки и внесение изменения
Создайте ветку, в которую вы сможете добавлять планы для космической станции, еще не готовые к коммиту. Когда вы будете готовы сообщить об этих планах всем, можно будет выполнить слияние изменений в репозиторий __*Bitbucket*__ и затем удалить ставшую ненужной ветку.

Важно понимать, что ветки — это просто указатели на коммиты. Когда вы создаете ветку, Git создает только новый указатель, а не новый набор файлов или папок. Перед началом работы ваш репозиторий выглядит так:

Создать ветку можно следующим образом:

В окне терминала перейдите на верхний уровень локального репозитория с помощью следующей команды:

```
cd ~/repos/bitbucketstationlocations/
```
В окне терминала создайте ветку.

__*$ git branch future-plans*__

Эта команда создает ветку, но не выполняет переключение на эту ветку, поэтому репозиторий выглядит примерно так:

Создайте ветку

История репозитория остается неизменной. Все, что вы получаете, — это новый указатель на текущую ветку. Чтобы начать работу с новой веткой, вы должны переключиться на ветку, которую хотите использовать.

Переключитесь на только что созданную ветку, чтобы начать ее использовать.

```
$ git checkout future-plans 
Switched to branch 'future-plans'
```
Команда git checkout часто используется вместе с командой git branch. Поскольку ветка создается для работы над чем-то новым, после каждого создания новой ветки (командой git branch) требуется переключиться на эту ветку (командой git checkout), чтобы начать ее использовать. Кода вы переключитесь на новую ветку, ваш рабочий процесс Git будет выглядеть примерно так:

### Функциональная ветка

Найдите в локальной системе папку bitbucketstationlocations и откройте ее. Вы заметите, что в результате создания новой ветки в каталоге не появилось никаких дополнительных файлов или папок.

Откройте файл stationlocations в текстовом редакторе.

Измените файл, добавив в него местоположение еще одной станции:

```
<p>Bitbucket has the following space stations:</p>
<p>
   <b>Earth's Moon</b><br>
   Headquarters
</p>
<p>
   <b>Mars</b><br>
   Recreation Department
</p>
```
Сохраните и закройте файл.

Введите в окне терминала команду git status. Вы увидите что-то подобное:

```
$ git status 
On branch future-plans
Changes not staged for commit:
 (use "git add <file>..." to update what will be committed)
 (use "git checkout -- <file>..." to discard changes in working directory)
   modified: stationlocations
no changes added to commit (use "git add" and/or "git commit -a")
```
Обратили внимание на строку On branch future-plans? Если бы вы ввели команду git status раньше, то вместо этой строки увидели бы строку branch main, потому что тогда у вас была только одна ветка — main. Прежде чем индексировать изменение или выполнять его коммит, всегда проверяйте эту строку, чтобы убедиться, что выбрана именно та ветка, в которую вы хотите добавить изменение.

Проиндексируйте свой файл.

```
$ git add stationlocations
```
В окне терминала введите команду git commit, как показано ниже:

```
$ git commit stationlocations -m 'making a change in a branch' 
[future-plans e3b7732] making a change in a branch
1 file changed, 4 insertions(+)
```
После этого последнего коммита репозиторий будет выглядеть примерно так:

Коммит функциональной ветки
Теперь пришло время объединить сделанное изменение с веткой main.

## Шаг 2. Merge для ветки: ускоренное слияние

Число ваших космических станций растет. Пришло время для церемонии открытия станции на Марсе. Теперь, когда ваши планы на будущее начали воплощаться в жизнь, можно слить ветку future-plans с основной веткой в локальной системе.

Поскольку вы создали только одну ветку и внесли одно изменение, используйте метод ускоренного слияния веток. Ускоренное слияние возможно, потому что последний коммит текущей ветки является прямым продолжением целевой ветки. В этом случае для объединения историй Git не выполняет полноценное слияние, а просто переносит указатель текущей ветки в конец целевой ветки. Объединение историй проходит успешно, поскольку все коммиты, доступные из целевой ветки, теперь доступны из текущей ветки.

Ускоренное слияние
Это распространенная модель работы с ветками, отведенными под решение краткосрочных задач с небольшими изменениями. При работе с объемными функциями она используется реже.

Ускоренное слияние можно выполнить следующим образом:

В окне терминала перейдите на верхний уровень локального репозитория.

```
 $ cd ~/repos/bitbucketstationlocations/
```
Введите команду git status, чтобы убедиться, что для всех изменений сделаны коммиты, и узнать, какая ветка выбрана.
По сути, вы переместили указатель ветки main вперед, к текущему указателю HEAD, и репозиторий выглядит как после ускоренного слияния, описанного выше.
Поскольку вы больше не планируете использовать ветку future-plans, ее можно удалить.

```
$ git branch -d future-plans 
Deleted branch future-plans (was e3b7732).
```
После удаления ветки future-plans вы сможете получить к ней доступ из ветки main через идентификатор коммита. Если, например, вы хотите отменить изменения, добавленные из ветки future-plans, воспользуйтесь полученным идентификатором коммита для возврата к этой ветке.
Введите команду git status, чтобы увидеть результаты слияния. Они показывают, что локальный репозиторий опережает удаленный на один коммит. Это будет выглядеть примерно так:

```
$ git status 
On branch main
Your branch is ahead of 'origin/main' by 1 commit.
 (use "git push" to publish your local commits)
nothing to commit, working directory clean
```
Вот что вы сделали на данный момент:

Создали ветку и переключились на нее
Внесли изменение в новую ветку
Сделали коммит изменения в новой ветке
Интегрировали изменение в основную ветку
Удалили ветку, ставшую ненужной
Теперь нужно поместить всю эту работу в Bitbucket, в удаленный репозиторий.

## Шаг 3. Отправьте изменения в Bitbucket
Вы хотите, чтобы все могли видеть местоположение новой космической станции. Для этого нужно передать текущее состояние локального репозитория в Bitbucket.

На схеме показано, что происходит, когда локальный репозиторий содержит изменения, которых нет в центральном репозитории, и вы отправляете эти изменения в __*Bitbucket*__.

До и после отправки ветки
Вот как можно отправить изменение в удаленный репозиторий:

Находясь в каталоге репозитория, введите в окне терминала команду **git push origin main**, чтобы отправить изменения. Результат будет выглядеть примерно так:
 ```
 $ git push origin main 
Counting objects: 3, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (3/3), done.
Writing objects: 100% (3/3), 401 bytes | 0 bytes/s, done.
Total 3 (delta 0), reused 0 (delta 0)
To https://emmap1@bitbucket.org/emmap1/bitbucketstationlocations.git
  fcbeeb0..e3b7732 main -> main
```

Перейдите на страницу Overview (Обзор) своего репозитория Bitbucket. Обратите внимание, что в ленте Recent Activity (Недавние события) появилась операция push.

Нажмите Commits (Коммиты), и вы увидите коммит, сделанный в локальной системе. Обратите внимание: изменение имеет тот же идентификатор коммита, что и в локальной системе.

### История коммитов

Также видно, что линия слева от списка коммитов является прямой и не имеет веток. Это связано с тем, что ветка future-plans никогда не взаимодействовала с удаленным репозиторием. Туда передавалось только созданное изменение после коммита.

Нажмите Branches (Ветки) и обратите внимание, что на этой странице также нет записи об этой ветке.

Нажмите Source (Исходный код), затем нажмите файл stationlocations. Вы увидите, что последнее изменение файла имеет тот же идентификатор коммита, что и отправленное.

Нажмите историю файла, чтобы просмотреть изменения этого файла, отправленные в виде коммитов. Она будет выглядеть примерно как на следующем рисунке.

История файла

## Готово!
Не уверены, что сможете запомнить все только что выученные команды Git? Не вопрос. Добавьте закладку на нашу страницу Основные команды Git и обращайтесь к ней при необходимости.


```
$ git status 
On branch future-plans
nothing to commit, working directory clean
```
Переключитесь на ветку main.
```
$ git checkout main 
Switched to branch 'main'
Your branch is up-to-date with 'origin/main'.
```
Выполните слияние изменений из ветки future-plans с веткой main. Это будет выглядеть примерно так: